// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mockdb

import (
	"context"
	"time"

	"github.com/alwitt/haven/db"
	"github.com/alwitt/haven/models"
	mock "github.com/stretchr/testify/mock"
)

// NewDatabase creates a new instance of Database. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDatabase(t interface {
	mock.TestingT
	Cleanup(func())
}) *Database {
	mock := &Database{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Database is an autogenerated mock type for the Database type
type Database struct {
	mock.Mock
}

type Database_Expecter struct {
	mock *mock.Mock
}

func (_m *Database) EXPECT() *Database_Expecter {
	return &Database_Expecter{mock: &_m.Mock}
}

// DefineNewRecord provides a mock function for the type Database
func (_mock *Database) DefineNewRecord(ctx context.Context, name string) (models.Record, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for DefineNewRecord")
	}

	var r0 models.Record
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (models.Record, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) models.Record); ok {
		r0 = returnFunc(ctx, name)
	} else {
		r0 = ret.Get(0).(models.Record)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_DefineNewRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefineNewRecord'
type Database_DefineNewRecord_Call struct {
	*mock.Call
}

// DefineNewRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) DefineNewRecord(ctx interface{}, name interface{}) *Database_DefineNewRecord_Call {
	return &Database_DefineNewRecord_Call{Call: _e.mock.On("DefineNewRecord", ctx, name)}
}

func (_c *Database_DefineNewRecord_Call) Run(run func(ctx context.Context, name string)) *Database_DefineNewRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_DefineNewRecord_Call) Return(record models.Record, err error) *Database_DefineNewRecord_Call {
	_c.Call.Return(record, err)
	return _c
}

func (_c *Database_DefineNewRecord_Call) RunAndReturn(run func(ctx context.Context, name string) (models.Record, error)) *Database_DefineNewRecord_Call {
	_c.Call.Return(run)
	return _c
}

// DefineNewVersionForRecord provides a mock function for the type Database
func (_mock *Database) DefineNewVersionForRecord(ctx context.Context, record models.Record, encKey models.EncryptionKey, value []byte, nonce []byte, timestamp time.Time) (models.RecordVersion, error) {
	ret := _mock.Called(ctx, record, encKey, value, nonce, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for DefineNewVersionForRecord")
	}

	var r0 models.RecordVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Record, models.EncryptionKey, []byte, []byte, time.Time) (models.RecordVersion, error)); ok {
		return returnFunc(ctx, record, encKey, value, nonce, timestamp)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Record, models.EncryptionKey, []byte, []byte, time.Time) models.RecordVersion); ok {
		r0 = returnFunc(ctx, record, encKey, value, nonce, timestamp)
	} else {
		r0 = ret.Get(0).(models.RecordVersion)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.Record, models.EncryptionKey, []byte, []byte, time.Time) error); ok {
		r1 = returnFunc(ctx, record, encKey, value, nonce, timestamp)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_DefineNewVersionForRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefineNewVersionForRecord'
type Database_DefineNewVersionForRecord_Call struct {
	*mock.Call
}

// DefineNewVersionForRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - record models.Record
//   - encKey models.EncryptionKey
//   - value []byte
//   - nonce []byte
//   - timestamp time.Time
func (_e *Database_Expecter) DefineNewVersionForRecord(ctx interface{}, record interface{}, encKey interface{}, value interface{}, nonce interface{}, timestamp interface{}) *Database_DefineNewVersionForRecord_Call {
	return &Database_DefineNewVersionForRecord_Call{Call: _e.mock.On("DefineNewVersionForRecord", ctx, record, encKey, value, nonce, timestamp)}
}

func (_c *Database_DefineNewVersionForRecord_Call) Run(run func(ctx context.Context, record models.Record, encKey models.EncryptionKey, value []byte, nonce []byte, timestamp time.Time)) *Database_DefineNewVersionForRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.Record
		if args[1] != nil {
			arg1 = args[1].(models.Record)
		}
		var arg2 models.EncryptionKey
		if args[2] != nil {
			arg2 = args[2].(models.EncryptionKey)
		}
		var arg3 []byte
		if args[3] != nil {
			arg3 = args[3].([]byte)
		}
		var arg4 []byte
		if args[4] != nil {
			arg4 = args[4].([]byte)
		}
		var arg5 time.Time
		if args[5] != nil {
			arg5 = args[5].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *Database_DefineNewVersionForRecord_Call) Return(recordVersion models.RecordVersion, err error) *Database_DefineNewVersionForRecord_Call {
	_c.Call.Return(recordVersion, err)
	return _c
}

func (_c *Database_DefineNewVersionForRecord_Call) RunAndReturn(run func(ctx context.Context, record models.Record, encKey models.EncryptionKey, value []byte, nonce []byte, timestamp time.Time) (models.RecordVersion, error)) *Database_DefineNewVersionForRecord_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEncryptionKey provides a mock function for the type Database
func (_mock *Database) DeleteEncryptionKey(ctx context.Context, keyID string) error {
	ret := _mock.Called(ctx, keyID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEncryptionKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, keyID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Database_DeleteEncryptionKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEncryptionKey'
type Database_DeleteEncryptionKey_Call struct {
	*mock.Call
}

// DeleteEncryptionKey is a helper method to define mock.On call
//   - ctx context.Context
//   - keyID string
func (_e *Database_Expecter) DeleteEncryptionKey(ctx interface{}, keyID interface{}) *Database_DeleteEncryptionKey_Call {
	return &Database_DeleteEncryptionKey_Call{Call: _e.mock.On("DeleteEncryptionKey", ctx, keyID)}
}

func (_c *Database_DeleteEncryptionKey_Call) Run(run func(ctx context.Context, keyID string)) *Database_DeleteEncryptionKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_DeleteEncryptionKey_Call) Return(err error) *Database_DeleteEncryptionKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Database_DeleteEncryptionKey_Call) RunAndReturn(run func(ctx context.Context, keyID string) error) *Database_DeleteEncryptionKey_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRecord provides a mock function for the type Database
func (_mock *Database) DeleteRecord(ctx context.Context, recordID string) error {
	ret := _mock.Called(ctx, recordID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRecord")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, recordID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Database_DeleteRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRecord'
type Database_DeleteRecord_Call struct {
	*mock.Call
}

// DeleteRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - recordID string
func (_e *Database_Expecter) DeleteRecord(ctx interface{}, recordID interface{}) *Database_DeleteRecord_Call {
	return &Database_DeleteRecord_Call{Call: _e.mock.On("DeleteRecord", ctx, recordID)}
}

func (_c *Database_DeleteRecord_Call) Run(run func(ctx context.Context, recordID string)) *Database_DeleteRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_DeleteRecord_Call) Return(err error) *Database_DeleteRecord_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Database_DeleteRecord_Call) RunAndReturn(run func(ctx context.Context, recordID string) error) *Database_DeleteRecord_Call {
	_c.Call.Return(run)
	return _c
}

// GetEncryptionKey provides a mock function for the type Database
func (_mock *Database) GetEncryptionKey(ctx context.Context, keyID string) (models.EncryptionKey, error) {
	ret := _mock.Called(ctx, keyID)

	if len(ret) == 0 {
		panic("no return value specified for GetEncryptionKey")
	}

	var r0 models.EncryptionKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (models.EncryptionKey, error)); ok {
		return returnFunc(ctx, keyID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) models.EncryptionKey); ok {
		r0 = returnFunc(ctx, keyID)
	} else {
		r0 = ret.Get(0).(models.EncryptionKey)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, keyID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_GetEncryptionKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEncryptionKey'
type Database_GetEncryptionKey_Call struct {
	*mock.Call
}

// GetEncryptionKey is a helper method to define mock.On call
//   - ctx context.Context
//   - keyID string
func (_e *Database_Expecter) GetEncryptionKey(ctx interface{}, keyID interface{}) *Database_GetEncryptionKey_Call {
	return &Database_GetEncryptionKey_Call{Call: _e.mock.On("GetEncryptionKey", ctx, keyID)}
}

func (_c *Database_GetEncryptionKey_Call) Run(run func(ctx context.Context, keyID string)) *Database_GetEncryptionKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_GetEncryptionKey_Call) Return(encryptionKey models.EncryptionKey, err error) *Database_GetEncryptionKey_Call {
	_c.Call.Return(encryptionKey, err)
	return _c
}

func (_c *Database_GetEncryptionKey_Call) RunAndReturn(run func(ctx context.Context, keyID string) (models.EncryptionKey, error)) *Database_GetEncryptionKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecord provides a mock function for the type Database
func (_mock *Database) GetRecord(ctx context.Context, recordID string) (models.Record, error) {
	ret := _mock.Called(ctx, recordID)

	if len(ret) == 0 {
		panic("no return value specified for GetRecord")
	}

	var r0 models.Record
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (models.Record, error)); ok {
		return returnFunc(ctx, recordID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) models.Record); ok {
		r0 = returnFunc(ctx, recordID)
	} else {
		r0 = ret.Get(0).(models.Record)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, recordID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_GetRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecord'
type Database_GetRecord_Call struct {
	*mock.Call
}

// GetRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - recordID string
func (_e *Database_Expecter) GetRecord(ctx interface{}, recordID interface{}) *Database_GetRecord_Call {
	return &Database_GetRecord_Call{Call: _e.mock.On("GetRecord", ctx, recordID)}
}

func (_c *Database_GetRecord_Call) Run(run func(ctx context.Context, recordID string)) *Database_GetRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_GetRecord_Call) Return(record models.Record, err error) *Database_GetRecord_Call {
	_c.Call.Return(record, err)
	return _c
}

func (_c *Database_GetRecord_Call) RunAndReturn(run func(ctx context.Context, recordID string) (models.Record, error)) *Database_GetRecord_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecordByName provides a mock function for the type Database
func (_mock *Database) GetRecordByName(ctx context.Context, recordName string) (models.Record, error) {
	ret := _mock.Called(ctx, recordName)

	if len(ret) == 0 {
		panic("no return value specified for GetRecordByName")
	}

	var r0 models.Record
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (models.Record, error)); ok {
		return returnFunc(ctx, recordName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) models.Record); ok {
		r0 = returnFunc(ctx, recordName)
	} else {
		r0 = ret.Get(0).(models.Record)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, recordName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_GetRecordByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecordByName'
type Database_GetRecordByName_Call struct {
	*mock.Call
}

// GetRecordByName is a helper method to define mock.On call
//   - ctx context.Context
//   - recordName string
func (_e *Database_Expecter) GetRecordByName(ctx interface{}, recordName interface{}) *Database_GetRecordByName_Call {
	return &Database_GetRecordByName_Call{Call: _e.mock.On("GetRecordByName", ctx, recordName)}
}

func (_c *Database_GetRecordByName_Call) Run(run func(ctx context.Context, recordName string)) *Database_GetRecordByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_GetRecordByName_Call) Return(record models.Record, err error) *Database_GetRecordByName_Call {
	_c.Call.Return(record, err)
	return _c
}

func (_c *Database_GetRecordByName_Call) RunAndReturn(run func(ctx context.Context, recordName string) (models.Record, error)) *Database_GetRecordByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecordVersion provides a mock function for the type Database
func (_mock *Database) GetRecordVersion(ctx context.Context, versionID string) (models.RecordVersion, error) {
	ret := _mock.Called(ctx, versionID)

	if len(ret) == 0 {
		panic("no return value specified for GetRecordVersion")
	}

	var r0 models.RecordVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (models.RecordVersion, error)); ok {
		return returnFunc(ctx, versionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) models.RecordVersion); ok {
		r0 = returnFunc(ctx, versionID)
	} else {
		r0 = ret.Get(0).(models.RecordVersion)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, versionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_GetRecordVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecordVersion'
type Database_GetRecordVersion_Call struct {
	*mock.Call
}

// GetRecordVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - versionID string
func (_e *Database_Expecter) GetRecordVersion(ctx interface{}, versionID interface{}) *Database_GetRecordVersion_Call {
	return &Database_GetRecordVersion_Call{Call: _e.mock.On("GetRecordVersion", ctx, versionID)}
}

func (_c *Database_GetRecordVersion_Call) Run(run func(ctx context.Context, versionID string)) *Database_GetRecordVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_GetRecordVersion_Call) Return(recordVersion models.RecordVersion, err error) *Database_GetRecordVersion_Call {
	_c.Call.Return(recordVersion, err)
	return _c
}

func (_c *Database_GetRecordVersion_Call) RunAndReturn(run func(ctx context.Context, versionID string) (models.RecordVersion, error)) *Database_GetRecordVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemParamEntry provides a mock function for the type Database
func (_mock *Database) GetSystemParamEntry(ctx context.Context) (models.SystemParams, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetSystemParamEntry")
	}

	var r0 models.SystemParams
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (models.SystemParams, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) models.SystemParams); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(models.SystemParams)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_GetSystemParamEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemParamEntry'
type Database_GetSystemParamEntry_Call struct {
	*mock.Call
}

// GetSystemParamEntry is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) GetSystemParamEntry(ctx interface{}) *Database_GetSystemParamEntry_Call {
	return &Database_GetSystemParamEntry_Call{Call: _e.mock.On("GetSystemParamEntry", ctx)}
}

func (_c *Database_GetSystemParamEntry_Call) Run(run func(ctx context.Context)) *Database_GetSystemParamEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Database_GetSystemParamEntry_Call) Return(systemParams models.SystemParams, err error) *Database_GetSystemParamEntry_Call {
	_c.Call.Return(systemParams, err)
	return _c
}

func (_c *Database_GetSystemParamEntry_Call) RunAndReturn(run func(ctx context.Context) (models.SystemParams, error)) *Database_GetSystemParamEntry_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllRecordVersions provides a mock function for the type Database
func (_mock *Database) ListAllRecordVersions(ctx context.Context, filters db.RecordVersionQueryFilter) ([]models.RecordVersion, error) {
	ret := _mock.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListAllRecordVersions")
	}

	var r0 []models.RecordVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.RecordVersionQueryFilter) ([]models.RecordVersion, error)); ok {
		return returnFunc(ctx, filters)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.RecordVersionQueryFilter) []models.RecordVersion); ok {
		r0 = returnFunc(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.RecordVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.RecordVersionQueryFilter) error); ok {
		r1 = returnFunc(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_ListAllRecordVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllRecordVersions'
type Database_ListAllRecordVersions_Call struct {
	*mock.Call
}

// ListAllRecordVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - filters db.RecordVersionQueryFilter
func (_e *Database_Expecter) ListAllRecordVersions(ctx interface{}, filters interface{}) *Database_ListAllRecordVersions_Call {
	return &Database_ListAllRecordVersions_Call{Call: _e.mock.On("ListAllRecordVersions", ctx, filters)}
}

func (_c *Database_ListAllRecordVersions_Call) Run(run func(ctx context.Context, filters db.RecordVersionQueryFilter)) *Database_ListAllRecordVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.RecordVersionQueryFilter
		if args[1] != nil {
			arg1 = args[1].(db.RecordVersionQueryFilter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_ListAllRecordVersions_Call) Return(recordVersions []models.RecordVersion, err error) *Database_ListAllRecordVersions_Call {
	_c.Call.Return(recordVersions, err)
	return _c
}

func (_c *Database_ListAllRecordVersions_Call) RunAndReturn(run func(ctx context.Context, filters db.RecordVersionQueryFilter) ([]models.RecordVersion, error)) *Database_ListAllRecordVersions_Call {
	_c.Call.Return(run)
	return _c
}

// ListEncryptionKeys provides a mock function for the type Database
func (_mock *Database) ListEncryptionKeys(ctx context.Context, filters db.EncryptionKeyQueryFilter) ([]models.EncryptionKey, error) {
	ret := _mock.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListEncryptionKeys")
	}

	var r0 []models.EncryptionKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.EncryptionKeyQueryFilter) ([]models.EncryptionKey, error)); ok {
		return returnFunc(ctx, filters)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.EncryptionKeyQueryFilter) []models.EncryptionKey); ok {
		r0 = returnFunc(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.EncryptionKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.EncryptionKeyQueryFilter) error); ok {
		r1 = returnFunc(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_ListEncryptionKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEncryptionKeys'
type Database_ListEncryptionKeys_Call struct {
	*mock.Call
}

// ListEncryptionKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - filters db.EncryptionKeyQueryFilter
func (_e *Database_Expecter) ListEncryptionKeys(ctx interface{}, filters interface{}) *Database_ListEncryptionKeys_Call {
	return &Database_ListEncryptionKeys_Call{Call: _e.mock.On("ListEncryptionKeys", ctx, filters)}
}

func (_c *Database_ListEncryptionKeys_Call) Run(run func(ctx context.Context, filters db.EncryptionKeyQueryFilter)) *Database_ListEncryptionKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.EncryptionKeyQueryFilter
		if args[1] != nil {
			arg1 = args[1].(db.EncryptionKeyQueryFilter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_ListEncryptionKeys_Call) Return(encryptionKeys []models.EncryptionKey, err error) *Database_ListEncryptionKeys_Call {
	_c.Call.Return(encryptionKeys, err)
	return _c
}

func (_c *Database_ListEncryptionKeys_Call) RunAndReturn(run func(ctx context.Context, filters db.EncryptionKeyQueryFilter) ([]models.EncryptionKey, error)) *Database_ListEncryptionKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ListRecords provides a mock function for the type Database
func (_mock *Database) ListRecords(ctx context.Context, filters db.RecordQueryFilter) ([]models.Record, error) {
	ret := _mock.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListRecords")
	}

	var r0 []models.Record
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.RecordQueryFilter) ([]models.Record, error)); ok {
		return returnFunc(ctx, filters)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.RecordQueryFilter) []models.Record); ok {
		r0 = returnFunc(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Record)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.RecordQueryFilter) error); ok {
		r1 = returnFunc(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_ListRecords_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRecords'
type Database_ListRecords_Call struct {
	*mock.Call
}

// ListRecords is a helper method to define mock.On call
//   - ctx context.Context
//   - filters db.RecordQueryFilter
func (_e *Database_Expecter) ListRecords(ctx interface{}, filters interface{}) *Database_ListRecords_Call {
	return &Database_ListRecords_Call{Call: _e.mock.On("ListRecords", ctx, filters)}
}

func (_c *Database_ListRecords_Call) Run(run func(ctx context.Context, filters db.RecordQueryFilter)) *Database_ListRecords_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.RecordQueryFilter
		if args[1] != nil {
			arg1 = args[1].(db.RecordQueryFilter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_ListRecords_Call) Return(records []models.Record, err error) *Database_ListRecords_Call {
	_c.Call.Return(records, err)
	return _c
}

func (_c *Database_ListRecords_Call) RunAndReturn(run func(ctx context.Context, filters db.RecordQueryFilter) ([]models.Record, error)) *Database_ListRecords_Call {
	_c.Call.Return(run)
	return _c
}

// ListSystemEvents provides a mock function for the type Database
func (_mock *Database) ListSystemEvents(ctx context.Context, filters db.SystemEventQueryFilter) ([]models.SystemEventAudit, error) {
	ret := _mock.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListSystemEvents")
	}

	var r0 []models.SystemEventAudit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.SystemEventQueryFilter) ([]models.SystemEventAudit, error)); ok {
		return returnFunc(ctx, filters)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, db.SystemEventQueryFilter) []models.SystemEventAudit); ok {
		r0 = returnFunc(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.SystemEventAudit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, db.SystemEventQueryFilter) error); ok {
		r1 = returnFunc(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_ListSystemEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSystemEvents'
type Database_ListSystemEvents_Call struct {
	*mock.Call
}

// ListSystemEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - filters db.SystemEventQueryFilter
func (_e *Database_Expecter) ListSystemEvents(ctx interface{}, filters interface{}) *Database_ListSystemEvents_Call {
	return &Database_ListSystemEvents_Call{Call: _e.mock.On("ListSystemEvents", ctx, filters)}
}

func (_c *Database_ListSystemEvents_Call) Run(run func(ctx context.Context, filters db.SystemEventQueryFilter)) *Database_ListSystemEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 db.SystemEventQueryFilter
		if args[1] != nil {
			arg1 = args[1].(db.SystemEventQueryFilter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_ListSystemEvents_Call) Return(systemEventAudits []models.SystemEventAudit, err error) *Database_ListSystemEvents_Call {
	_c.Call.Return(systemEventAudits, err)
	return _c
}

func (_c *Database_ListSystemEvents_Call) RunAndReturn(run func(ctx context.Context, filters db.SystemEventQueryFilter) ([]models.SystemEventAudit, error)) *Database_ListSystemEvents_Call {
	_c.Call.Return(run)
	return _c
}

// ListVersionsEncryptedByKey provides a mock function for the type Database
func (_mock *Database) ListVersionsEncryptedByKey(ctx context.Context, encKey models.EncryptionKey, filters db.RecordVersionQueryFilter) ([]models.RecordVersion, error) {
	ret := _mock.Called(ctx, encKey, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListVersionsEncryptedByKey")
	}

	var r0 []models.RecordVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.EncryptionKey, db.RecordVersionQueryFilter) ([]models.RecordVersion, error)); ok {
		return returnFunc(ctx, encKey, filters)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.EncryptionKey, db.RecordVersionQueryFilter) []models.RecordVersion); ok {
		r0 = returnFunc(ctx, encKey, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.RecordVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.EncryptionKey, db.RecordVersionQueryFilter) error); ok {
		r1 = returnFunc(ctx, encKey, filters)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_ListVersionsEncryptedByKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVersionsEncryptedByKey'
type Database_ListVersionsEncryptedByKey_Call struct {
	*mock.Call
}

// ListVersionsEncryptedByKey is a helper method to define mock.On call
//   - ctx context.Context
//   - encKey models.EncryptionKey
//   - filters db.RecordVersionQueryFilter
func (_e *Database_Expecter) ListVersionsEncryptedByKey(ctx interface{}, encKey interface{}, filters interface{}) *Database_ListVersionsEncryptedByKey_Call {
	return &Database_ListVersionsEncryptedByKey_Call{Call: _e.mock.On("ListVersionsEncryptedByKey", ctx, encKey, filters)}
}

func (_c *Database_ListVersionsEncryptedByKey_Call) Run(run func(ctx context.Context, encKey models.EncryptionKey, filters db.RecordVersionQueryFilter)) *Database_ListVersionsEncryptedByKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.EncryptionKey
		if args[1] != nil {
			arg1 = args[1].(models.EncryptionKey)
		}
		var arg2 db.RecordVersionQueryFilter
		if args[2] != nil {
			arg2 = args[2].(db.RecordVersionQueryFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Database_ListVersionsEncryptedByKey_Call) Return(recordVersions []models.RecordVersion, err error) *Database_ListVersionsEncryptedByKey_Call {
	_c.Call.Return(recordVersions, err)
	return _c
}

func (_c *Database_ListVersionsEncryptedByKey_Call) RunAndReturn(run func(ctx context.Context, encKey models.EncryptionKey, filters db.RecordVersionQueryFilter) ([]models.RecordVersion, error)) *Database_ListVersionsEncryptedByKey_Call {
	_c.Call.Return(run)
	return _c
}

// ListVersionsOfOneRecord provides a mock function for the type Database
func (_mock *Database) ListVersionsOfOneRecord(ctx context.Context, record models.Record, filters db.RecordVersionQueryFilter) ([]models.RecordVersion, error) {
	ret := _mock.Called(ctx, record, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListVersionsOfOneRecord")
	}

	var r0 []models.RecordVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Record, db.RecordVersionQueryFilter) ([]models.RecordVersion, error)); ok {
		return returnFunc(ctx, record, filters)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Record, db.RecordVersionQueryFilter) []models.RecordVersion); ok {
		r0 = returnFunc(ctx, record, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.RecordVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.Record, db.RecordVersionQueryFilter) error); ok {
		r1 = returnFunc(ctx, record, filters)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_ListVersionsOfOneRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVersionsOfOneRecord'
type Database_ListVersionsOfOneRecord_Call struct {
	*mock.Call
}

// ListVersionsOfOneRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - record models.Record
//   - filters db.RecordVersionQueryFilter
func (_e *Database_Expecter) ListVersionsOfOneRecord(ctx interface{}, record interface{}, filters interface{}) *Database_ListVersionsOfOneRecord_Call {
	return &Database_ListVersionsOfOneRecord_Call{Call: _e.mock.On("ListVersionsOfOneRecord", ctx, record, filters)}
}

func (_c *Database_ListVersionsOfOneRecord_Call) Run(run func(ctx context.Context, record models.Record, filters db.RecordVersionQueryFilter)) *Database_ListVersionsOfOneRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.Record
		if args[1] != nil {
			arg1 = args[1].(models.Record)
		}
		var arg2 db.RecordVersionQueryFilter
		if args[2] != nil {
			arg2 = args[2].(db.RecordVersionQueryFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Database_ListVersionsOfOneRecord_Call) Return(recordVersions []models.RecordVersion, err error) *Database_ListVersionsOfOneRecord_Call {
	_c.Call.Return(recordVersions, err)
	return _c
}

func (_c *Database_ListVersionsOfOneRecord_Call) RunAndReturn(run func(ctx context.Context, record models.Record, filters db.RecordVersionQueryFilter) ([]models.RecordVersion, error)) *Database_ListVersionsOfOneRecord_Call {
	_c.Call.Return(run)
	return _c
}

// MarkEncryptionKeyActive provides a mock function for the type Database
func (_mock *Database) MarkEncryptionKeyActive(ctx context.Context, keyID string) error {
	ret := _mock.Called(ctx, keyID)

	if len(ret) == 0 {
		panic("no return value specified for MarkEncryptionKeyActive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, keyID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Database_MarkEncryptionKeyActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkEncryptionKeyActive'
type Database_MarkEncryptionKeyActive_Call struct {
	*mock.Call
}

// MarkEncryptionKeyActive is a helper method to define mock.On call
//   - ctx context.Context
//   - keyID string
func (_e *Database_Expecter) MarkEncryptionKeyActive(ctx interface{}, keyID interface{}) *Database_MarkEncryptionKeyActive_Call {
	return &Database_MarkEncryptionKeyActive_Call{Call: _e.mock.On("MarkEncryptionKeyActive", ctx, keyID)}
}

func (_c *Database_MarkEncryptionKeyActive_Call) Run(run func(ctx context.Context, keyID string)) *Database_MarkEncryptionKeyActive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_MarkEncryptionKeyActive_Call) Return(err error) *Database_MarkEncryptionKeyActive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Database_MarkEncryptionKeyActive_Call) RunAndReturn(run func(ctx context.Context, keyID string) error) *Database_MarkEncryptionKeyActive_Call {
	_c.Call.Return(run)
	return _c
}

// MarkEncryptionKeyInactive provides a mock function for the type Database
func (_mock *Database) MarkEncryptionKeyInactive(ctx context.Context, keyID string) error {
	ret := _mock.Called(ctx, keyID)

	if len(ret) == 0 {
		panic("no return value specified for MarkEncryptionKeyInactive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, keyID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Database_MarkEncryptionKeyInactive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkEncryptionKeyInactive'
type Database_MarkEncryptionKeyInactive_Call struct {
	*mock.Call
}

// MarkEncryptionKeyInactive is a helper method to define mock.On call
//   - ctx context.Context
//   - keyID string
func (_e *Database_Expecter) MarkEncryptionKeyInactive(ctx interface{}, keyID interface{}) *Database_MarkEncryptionKeyInactive_Call {
	return &Database_MarkEncryptionKeyInactive_Call{Call: _e.mock.On("MarkEncryptionKeyInactive", ctx, keyID)}
}

func (_c *Database_MarkEncryptionKeyInactive_Call) Run(run func(ctx context.Context, keyID string)) *Database_MarkEncryptionKeyInactive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_MarkEncryptionKeyInactive_Call) Return(err error) *Database_MarkEncryptionKeyInactive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Database_MarkEncryptionKeyInactive_Call) RunAndReturn(run func(ctx context.Context, keyID string) error) *Database_MarkEncryptionKeyInactive_Call {
	_c.Call.Return(run)
	return _c
}

// MarkSystemInitialized provides a mock function for the type Database
func (_mock *Database) MarkSystemInitialized(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for MarkSystemInitialized")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Database_MarkSystemInitialized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkSystemInitialized'
type Database_MarkSystemInitialized_Call struct {
	*mock.Call
}

// MarkSystemInitialized is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) MarkSystemInitialized(ctx interface{}) *Database_MarkSystemInitialized_Call {
	return &Database_MarkSystemInitialized_Call{Call: _e.mock.On("MarkSystemInitialized", ctx)}
}

func (_c *Database_MarkSystemInitialized_Call) Run(run func(ctx context.Context)) *Database_MarkSystemInitialized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Database_MarkSystemInitialized_Call) Return(err error) *Database_MarkSystemInitialized_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Database_MarkSystemInitialized_Call) RunAndReturn(run func(ctx context.Context) error) *Database_MarkSystemInitialized_Call {
	_c.Call.Return(run)
	return _c
}

// MarkSystemInitializing provides a mock function for the type Database
func (_mock *Database) MarkSystemInitializing(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for MarkSystemInitializing")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Database_MarkSystemInitializing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkSystemInitializing'
type Database_MarkSystemInitializing_Call struct {
	*mock.Call
}

// MarkSystemInitializing is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) MarkSystemInitializing(ctx interface{}) *Database_MarkSystemInitializing_Call {
	return &Database_MarkSystemInitializing_Call{Call: _e.mock.On("MarkSystemInitializing", ctx)}
}

func (_c *Database_MarkSystemInitializing_Call) Run(run func(ctx context.Context)) *Database_MarkSystemInitializing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Database_MarkSystemInitializing_Call) Return(err error) *Database_MarkSystemInitializing_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Database_MarkSystemInitializing_Call) RunAndReturn(run func(ctx context.Context) error) *Database_MarkSystemInitializing_Call {
	_c.Call.Return(run)
	return _c
}

// RecordEncryptionKey provides a mock function for the type Database
func (_mock *Database) RecordEncryptionKey(ctx context.Context, encKeyMaterial []byte) (models.EncryptionKey, error) {
	ret := _mock.Called(ctx, encKeyMaterial)

	if len(ret) == 0 {
		panic("no return value specified for RecordEncryptionKey")
	}

	var r0 models.EncryptionKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) (models.EncryptionKey, error)); ok {
		return returnFunc(ctx, encKeyMaterial)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) models.EncryptionKey); ok {
		r0 = returnFunc(ctx, encKeyMaterial)
	} else {
		r0 = ret.Get(0).(models.EncryptionKey)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = returnFunc(ctx, encKeyMaterial)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Database_RecordEncryptionKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordEncryptionKey'
type Database_RecordEncryptionKey_Call struct {
	*mock.Call
}

// RecordEncryptionKey is a helper method to define mock.On call
//   - ctx context.Context
//   - encKeyMaterial []byte
func (_e *Database_Expecter) RecordEncryptionKey(ctx interface{}, encKeyMaterial interface{}) *Database_RecordEncryptionKey_Call {
	return &Database_RecordEncryptionKey_Call{Call: _e.mock.On("RecordEncryptionKey", ctx, encKeyMaterial)}
}

func (_c *Database_RecordEncryptionKey_Call) Run(run func(ctx context.Context, encKeyMaterial []byte)) *Database_RecordEncryptionKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Database_RecordEncryptionKey_Call) Return(encryptionKey models.EncryptionKey, err error) *Database_RecordEncryptionKey_Call {
	_c.Call.Return(encryptionKey, err)
	return _c
}

func (_c *Database_RecordEncryptionKey_Call) RunAndReturn(run func(ctx context.Context, encKeyMaterial []byte) (models.EncryptionKey, error)) *Database_RecordEncryptionKey_Call {
	_c.Call.Return(run)
	return _c
}
