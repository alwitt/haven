// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mockstore

import (
	"context"
	"time"

	"github.com/alwitt/haven/db"
	"github.com/alwitt/haven/models"
	mock "github.com/stretchr/testify/mock"
)

// NewProtectedKVStore creates a new instance of ProtectedKVStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProtectedKVStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProtectedKVStore {
	mock := &ProtectedKVStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProtectedKVStore is an autogenerated mock type for the ProtectedKVStore type
type ProtectedKVStore struct {
	mock.Mock
}

type ProtectedKVStore_Expecter struct {
	mock *mock.Mock
}

func (_m *ProtectedKVStore) EXPECT() *ProtectedKVStore_Expecter {
	return &ProtectedKVStore_Expecter{mock: &_m.Mock}
}

// DeleteKey provides a mock function for the type ProtectedKVStore
func (_mock *ProtectedKVStore) DeleteKey(ctx context.Context, key string, activeDBClient db.Database) error {
	ret := _mock.Called(ctx, key, activeDBClient)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, db.Database) error); ok {
		r0 = returnFunc(ctx, key, activeDBClient)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProtectedKVStore_DeleteKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKey'
type ProtectedKVStore_DeleteKey_Call struct {
	*mock.Call
}

// DeleteKey is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - activeDBClient db.Database
func (_e *ProtectedKVStore_Expecter) DeleteKey(ctx interface{}, key interface{}, activeDBClient interface{}) *ProtectedKVStore_DeleteKey_Call {
	return &ProtectedKVStore_DeleteKey_Call{Call: _e.mock.On("DeleteKey", ctx, key, activeDBClient)}
}

func (_c *ProtectedKVStore_DeleteKey_Call) Run(run func(ctx context.Context, key string, activeDBClient db.Database)) *ProtectedKVStore_DeleteKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 db.Database
		if args[2] != nil {
			arg2 = args[2].(db.Database)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ProtectedKVStore_DeleteKey_Call) Return(err error) *ProtectedKVStore_DeleteKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProtectedKVStore_DeleteKey_Call) RunAndReturn(run func(ctx context.Context, key string, activeDBClient db.Database) error) *ProtectedKVStore_DeleteKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetValueOfKeyAtVersion provides a mock function for the type ProtectedKVStore
func (_mock *ProtectedKVStore) GetValueOfKeyAtVersion(ctx context.Context, versionEntry models.RecordVersion, activeDBClient db.Database) ([]byte, error) {
	ret := _mock.Called(ctx, versionEntry, activeDBClient)

	if len(ret) == 0 {
		panic("no return value specified for GetValueOfKeyAtVersion")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.RecordVersion, db.Database) ([]byte, error)); ok {
		return returnFunc(ctx, versionEntry, activeDBClient)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.RecordVersion, db.Database) []byte); ok {
		r0 = returnFunc(ctx, versionEntry, activeDBClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.RecordVersion, db.Database) error); ok {
		r1 = returnFunc(ctx, versionEntry, activeDBClient)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProtectedKVStore_GetValueOfKeyAtVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValueOfKeyAtVersion'
type ProtectedKVStore_GetValueOfKeyAtVersion_Call struct {
	*mock.Call
}

// GetValueOfKeyAtVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - versionEntry models.RecordVersion
//   - activeDBClient db.Database
func (_e *ProtectedKVStore_Expecter) GetValueOfKeyAtVersion(ctx interface{}, versionEntry interface{}, activeDBClient interface{}) *ProtectedKVStore_GetValueOfKeyAtVersion_Call {
	return &ProtectedKVStore_GetValueOfKeyAtVersion_Call{Call: _e.mock.On("GetValueOfKeyAtVersion", ctx, versionEntry, activeDBClient)}
}

func (_c *ProtectedKVStore_GetValueOfKeyAtVersion_Call) Run(run func(ctx context.Context, versionEntry models.RecordVersion, activeDBClient db.Database)) *ProtectedKVStore_GetValueOfKeyAtVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.RecordVersion
		if args[1] != nil {
			arg1 = args[1].(models.RecordVersion)
		}
		var arg2 db.Database
		if args[2] != nil {
			arg2 = args[2].(db.Database)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ProtectedKVStore_GetValueOfKeyAtVersion_Call) Return(bytes []byte, err error) *ProtectedKVStore_GetValueOfKeyAtVersion_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *ProtectedKVStore_GetValueOfKeyAtVersion_Call) RunAndReturn(run func(ctx context.Context, versionEntry models.RecordVersion, activeDBClient db.Database) ([]byte, error)) *ProtectedKVStore_GetValueOfKeyAtVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetValueOfKeyAtVersionID provides a mock function for the type ProtectedKVStore
func (_mock *ProtectedKVStore) GetValueOfKeyAtVersionID(ctx context.Context, versionID string, activeDBClient db.Database) ([]byte, error) {
	ret := _mock.Called(ctx, versionID, activeDBClient)

	if len(ret) == 0 {
		panic("no return value specified for GetValueOfKeyAtVersionID")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, db.Database) ([]byte, error)); ok {
		return returnFunc(ctx, versionID, activeDBClient)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, db.Database) []byte); ok {
		r0 = returnFunc(ctx, versionID, activeDBClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, db.Database) error); ok {
		r1 = returnFunc(ctx, versionID, activeDBClient)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProtectedKVStore_GetValueOfKeyAtVersionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValueOfKeyAtVersionID'
type ProtectedKVStore_GetValueOfKeyAtVersionID_Call struct {
	*mock.Call
}

// GetValueOfKeyAtVersionID is a helper method to define mock.On call
//   - ctx context.Context
//   - versionID string
//   - activeDBClient db.Database
func (_e *ProtectedKVStore_Expecter) GetValueOfKeyAtVersionID(ctx interface{}, versionID interface{}, activeDBClient interface{}) *ProtectedKVStore_GetValueOfKeyAtVersionID_Call {
	return &ProtectedKVStore_GetValueOfKeyAtVersionID_Call{Call: _e.mock.On("GetValueOfKeyAtVersionID", ctx, versionID, activeDBClient)}
}

func (_c *ProtectedKVStore_GetValueOfKeyAtVersionID_Call) Run(run func(ctx context.Context, versionID string, activeDBClient db.Database)) *ProtectedKVStore_GetValueOfKeyAtVersionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 db.Database
		if args[2] != nil {
			arg2 = args[2].(db.Database)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ProtectedKVStore_GetValueOfKeyAtVersionID_Call) Return(bytes []byte, err error) *ProtectedKVStore_GetValueOfKeyAtVersionID_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *ProtectedKVStore_GetValueOfKeyAtVersionID_Call) RunAndReturn(run func(ctx context.Context, versionID string, activeDBClient db.Database) ([]byte, error)) *ProtectedKVStore_GetValueOfKeyAtVersionID_Call {
	_c.Call.Return(run)
	return _c
}

// ListKeyVersions provides a mock function for the type ProtectedKVStore
func (_mock *ProtectedKVStore) ListKeyVersions(ctx context.Context, key string, activeDBClient db.Database) (models.Record, []models.RecordVersion, error) {
	ret := _mock.Called(ctx, key, activeDBClient)

	if len(ret) == 0 {
		panic("no return value specified for ListKeyVersions")
	}

	var r0 models.Record
	var r1 []models.RecordVersion
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, db.Database) (models.Record, []models.RecordVersion, error)); ok {
		return returnFunc(ctx, key, activeDBClient)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, db.Database) models.Record); ok {
		r0 = returnFunc(ctx, key, activeDBClient)
	} else {
		r0 = ret.Get(0).(models.Record)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, db.Database) []models.RecordVersion); ok {
		r1 = returnFunc(ctx, key, activeDBClient)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]models.RecordVersion)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, db.Database) error); ok {
		r2 = returnFunc(ctx, key, activeDBClient)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ProtectedKVStore_ListKeyVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListKeyVersions'
type ProtectedKVStore_ListKeyVersions_Call struct {
	*mock.Call
}

// ListKeyVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - activeDBClient db.Database
func (_e *ProtectedKVStore_Expecter) ListKeyVersions(ctx interface{}, key interface{}, activeDBClient interface{}) *ProtectedKVStore_ListKeyVersions_Call {
	return &ProtectedKVStore_ListKeyVersions_Call{Call: _e.mock.On("ListKeyVersions", ctx, key, activeDBClient)}
}

func (_c *ProtectedKVStore_ListKeyVersions_Call) Run(run func(ctx context.Context, key string, activeDBClient db.Database)) *ProtectedKVStore_ListKeyVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 db.Database
		if args[2] != nil {
			arg2 = args[2].(db.Database)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ProtectedKVStore_ListKeyVersions_Call) Return(record models.Record, recordVersions []models.RecordVersion, err error) *ProtectedKVStore_ListKeyVersions_Call {
	_c.Call.Return(record, recordVersions, err)
	return _c
}

func (_c *ProtectedKVStore_ListKeyVersions_Call) RunAndReturn(run func(ctx context.Context, key string, activeDBClient db.Database) (models.Record, []models.RecordVersion, error)) *ProtectedKVStore_ListKeyVersions_Call {
	_c.Call.Return(run)
	return _c
}

// RecordKeyValue provides a mock function for the type ProtectedKVStore
func (_mock *ProtectedKVStore) RecordKeyValue(ctx context.Context, key string, value []byte, timestamp time.Time, activeDBClient db.Database) (models.Record, models.RecordVersion, error) {
	ret := _mock.Called(ctx, key, value, timestamp, activeDBClient)

	if len(ret) == 0 {
		panic("no return value specified for RecordKeyValue")
	}

	var r0 models.Record
	var r1 models.RecordVersion
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte, time.Time, db.Database) (models.Record, models.RecordVersion, error)); ok {
		return returnFunc(ctx, key, value, timestamp, activeDBClient)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte, time.Time, db.Database) models.Record); ok {
		r0 = returnFunc(ctx, key, value, timestamp, activeDBClient)
	} else {
		r0 = ret.Get(0).(models.Record)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []byte, time.Time, db.Database) models.RecordVersion); ok {
		r1 = returnFunc(ctx, key, value, timestamp, activeDBClient)
	} else {
		r1 = ret.Get(1).(models.RecordVersion)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, []byte, time.Time, db.Database) error); ok {
		r2 = returnFunc(ctx, key, value, timestamp, activeDBClient)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ProtectedKVStore_RecordKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordKeyValue'
type ProtectedKVStore_RecordKeyValue_Call struct {
	*mock.Call
}

// RecordKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value []byte
//   - timestamp time.Time
//   - activeDBClient db.Database
func (_e *ProtectedKVStore_Expecter) RecordKeyValue(ctx interface{}, key interface{}, value interface{}, timestamp interface{}, activeDBClient interface{}) *ProtectedKVStore_RecordKeyValue_Call {
	return &ProtectedKVStore_RecordKeyValue_Call{Call: _e.mock.On("RecordKeyValue", ctx, key, value, timestamp, activeDBClient)}
}

func (_c *ProtectedKVStore_RecordKeyValue_Call) Run(run func(ctx context.Context, key string, value []byte, timestamp time.Time, activeDBClient db.Database)) *ProtectedKVStore_RecordKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		var arg4 db.Database
		if args[4] != nil {
			arg4 = args[4].(db.Database)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *ProtectedKVStore_RecordKeyValue_Call) Return(record models.Record, recordVersion models.RecordVersion, err error) *ProtectedKVStore_RecordKeyValue_Call {
	_c.Call.Return(record, recordVersion, err)
	return _c
}

func (_c *ProtectedKVStore_RecordKeyValue_Call) RunAndReturn(run func(ctx context.Context, key string, value []byte, timestamp time.Time, activeDBClient db.Database) (models.Record, models.RecordVersion, error)) *ProtectedKVStore_RecordKeyValue_Call {
	_c.Call.Return(run)
	return _c
}
